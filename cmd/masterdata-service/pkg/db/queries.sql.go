// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
)

const createCountry = `-- name: CreateCountry :exec
INSERT INTO countries (area_id) VALUES ($1)
`

func (q *Queries) CreateCountry(ctx context.Context, areaID int32) error {
	_, err := q.db.ExecContext(ctx, createCountry, areaID)
	return err
}

const getAllAreas = `-- name: GetAllAreas :many
SELECT areas.id AS area_id, areas.country_name, areas.country_code, 
       regions.name AS region_name, currencies.name AS currency_name
FROM areas
JOIN regions ON areas.region_id = regions.id
JOIN currencies ON areas.currency_id = currencies.id
`

type GetAllAreasRow struct {
	AreaID       int32
	CountryName  string
	CountryCode  string
	RegionName   string
	CurrencyName string
}

func (q *Queries) GetAllAreas(ctx context.Context) ([]GetAllAreasRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllAreas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllAreasRow
	for rows.Next() {
		var i GetAllAreasRow
		if err := rows.Scan(
			&i.AreaID,
			&i.CountryName,
			&i.CountryCode,
			&i.RegionName,
			&i.CurrencyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCurrencies = `-- name: GetAllCurrencies :many
SELECT id, name, code
FROM currencies
`

func (q *Queries) GetAllCurrencies(ctx context.Context) ([]Currency, error) {
	rows, err := q.db.QueryContext(ctx, getAllCurrencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Currency
	for rows.Next() {
		var i Currency
		if err := rows.Scan(&i.ID, &i.Name, &i.Code); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRegions = `-- name: GetAllRegions :many
SELECT id, name
FROM regions
`

func (q *Queries) GetAllRegions(ctx context.Context) ([]Region, error) {
	rows, err := q.db.QueryContext(ctx, getAllRegions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Region
	for rows.Next() {
		var i Region
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountryByID = `-- name: GetCountryByID :one
SELECT countries.id AS country_id, areas.country_name, areas.country_code, 
       regions.name AS region_name, currencies.name AS currency_name
FROM countries
JOIN areas ON countries.area_id = areas.id
JOIN regions ON areas.region_id = regions.id
JOIN currencies ON areas.currency_id = currencies.id
WHERE countries.id = $1
`

type GetCountryByIDRow struct {
	CountryID    int32
	CountryName  string
	CountryCode  string
	RegionName   string
	CurrencyName string
}

func (q *Queries) GetCountryByID(ctx context.Context, id int32) (GetCountryByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getCountryByID, id)
	var i GetCountryByIDRow
	err := row.Scan(
		&i.CountryID,
		&i.CountryName,
		&i.CountryCode,
		&i.RegionName,
		&i.CurrencyName,
	)
	return i, err
}
